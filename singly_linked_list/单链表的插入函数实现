单链表的插入函数实现

一、这里首先区分两个概念：链表的头节点和链表的第一个节点

对于一个链表，其可以是带头节点或不带头节点，当这个链表带有头节点时：
头节点：用于标识整个链表,获取到头节点也就获取到整个链表。其数据域没有任何意义。
		该节点总是位于链表的开头位置。而链表的第一个节点是继该节点之后的第一个节点。

第一个节点：就是链表中众多节点中的普通的一个。其位于头节点之后的第一个位置。这个节点的数据域是有意义的。

当链表不带有头节点时，从地理位置上来说，第一个节点也可以叫做头节点。

二、单链表的插入函数实现
插入函数需要考虑一个特殊情况，正确的处理该特殊情况，才能让插入功能变得完整。
特殊情况：插入位置在第一个节点之前.

将头节点引入单链表，可以简化这个问题，化特殊为一般。
有了头节点之后，那么所有节点的插入，都是在头节点之后。不会考虑当第一个节点之前的节点为空的情况。具体实现见后续代码。


我们也可以不引入头节点，而是正面的去处理这个特殊情况，将该情况提出来进行单独处理；
当然，也可以通过一些技巧在没有头节点的情况下实现化特殊为一般。


1. 带有头节点的单链表插入函数实现（代码实现：insert6.c）
从main函数的代码可知，插入操作必须寄托与已有的链表之上，即链表必须存在一个头节点。
在实现过程中，当插入位置在第一个节点之前时，处理方式和其他节点一样。

2. 不带头节点的单链表插入函数实现(代码来自《c和指针》) （代码实现：insert1-5.c －－1到5依次进化）
从main函数的代码可知，插入操作在头节点（地理位置）的地址为NULL时，仍然能够插入。

1) 正面处理特殊情况（代码实现：insert1-3.c）
检测当前节点的前节点是否为NULL,如果是，则表明插入的位置在第一个节点之前。
if(previous == NULL)
	*root ＝ newnode;
else
	previous->next = newnode;

2) 化特殊为一般(代码实现：insert4-5.c)
其实，每个节点都有一个指针指向他们，我们在插入节点时，实际上是修改的这些指针。不同的是，
对于第一个节点，我们会声明它为Node *root，所以指向第一个节点的指针是root;(该指针并不在节点内部)
而对于后续其他节点，指向它们的分别是其对应前节点的link字段。（该link指针在节点内部）
如果我们在遍历链表，寻找插入位置时，保留当前节点的link变量的值（指针），则可在插入时直接去修改这些link的值。
注意：保存link的值需要用到指针的指针。对于第一个节点，可以声明为Node **linkp，即用linkp保留指向第一个节点的指针*linkp的值。而获取节点link的地址只需要：&(*linkp)->link

我们用linkp来保留当前节点的link的地址。所以，以下语句可以化特殊为一般：(插入位置时当前节点和其下一个节点之间)
new->link = next; 
*linkp = new;


